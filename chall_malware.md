
ğŸš§ ==Attention== : Ici ce ne sont pas des vrais malware, mais il est recommandÃ© (obligatoire) de les lancer dans une VM dÃ©connectÃ©e du rÃ©seau (avec prise de snapshot) ou Ã  minima dans un docker.

```bash
docker run --rm -it -v ./malware.bin:/malware.bin ubuntu:22.04
```
### Kill switch

>consigne : Trouvez le kill switch pour dÃ©sactiver le malware

ğŸ’½ binaire : 1_chall

ğŸ•µï¸â€â™€ï¸ Ici on a une fonction main qui ressemble Ã  Ã§a (aprÃ¨s renommage des fonctions) :

![](attachment/59aaa2e4c44a7d8a8d074024a4b64edb.png)

ğŸ•µï¸â€â™€ï¸ Donc il faut qu'on valide "first verification" et "second vÃ©rification" pour remporter le flag

##### first verification

ğŸ•µï¸â€â™€ï¸ Pour cette premiÃ¨re vÃ©rification, c'est plutÃ´t simple, le malware check si un fichier folder dans le rÃ©pertoire "/I/dont/know/this/" contient "IWANTTOSTOP" :

![](attachment/d8e343882c31aab866684be006cc8871.png)

ğŸ•µï¸â€â™€ï¸ On prÃ©pare notre code python pour gÃ©nÃ©rer ce fichier : 

```python
from pwn import *
import os


path = './I/dont/know/this/'
contenu = "IWANTTOSTOP"

file_name = "folder"
os.makedirs(path, exist_ok=True)

file_path = os.path.join(path, file_name)

with open(file_path, "w", encoding="utf-8") as file:
    file.write(contenu)

print(f"Fichier crÃ©Ã© et rempli avec succÃ¨s Ã  : {file_path}")
```

##### DeuxiÃ¨me vÃ©rification

ğŸ•µï¸â€â™‚ï¸ Ici, on doit valider "second_verification" :

![](attachment/dc4d7e77a8c14f3cf1a5184446655832.png)

Mais, qu'est-ce qu'on attend comme retour pour valider le IF ? allons voir le code assembleur : 

![](attachment/c0aafa1964a7b72a83f8a67eb3d78c90.png)
	 
ğŸ•µï¸â€â™‚ï¸ Si eax = 0 le zero flag et mis Ã  0 et on saute vers print_flag, 

ğŸ•µï¸â€â™‚ï¸ Du coup, dans la fonction "second_verification" il nous faut une valeur de retour Ã  0 : 

![](attachment/d31206f7e47252c2f8e1aabf6736b988.png)
![](attachment/92df5cd889846625f11e4f510e89efca.png)

ğŸ•µï¸â€â™‚ï¸ Pour avoir une valeur de retour Ã  0 il faut, donc, que le binaire arrive Ã  rÃ©soudre "IAMSURETHAT.com"

ğŸ•µï¸â€â™‚ï¸ Hors, si on se rappelle nos cours de rÃ©seau ! Notre resolveur dns local sera interrogÃ© en premier. Du coup, il nous faut juste remplir notre fichier /etc/hosts (linux) ou C:\Windows\System32\Drivers\etc\hosts (windows)

ğŸ•µï¸â€â™‚ï¸ On ajoute ce check dans notre  python : 

```python
from pwn import *
import os


path = '/I/dont/know/this/'
contenu = "IWANTTOSTOP"
file_name = "folder"

host_path = '/etc/hosts'
dns_entry = "127.0.0.1 IAMSURETHAT.com"

os.makedirs(path, exist_ok=True)

file_path = os.path.join(path, file_name)

with open(file_path, "w", encoding="utf-8") as file:
    file.write(contenu)

with open(host_path,"a", encoding="utf-8") as file:
    file.write(dns_entry)

io = process(["./1_chal"])

io.interactive()
```
![](attachment/09ad2ed4f956e9aa0575a40e1e93d210.png)
ğŸ‡

### Malware

>consigne : Ma grand-mÃ¨re a reÃ§u un mail contenant cet executable. Ca me semble louche mais je n'arrive pas Ã  dire pourquoi. Je vous donne un accÃ¨s Ã  son pc, pouvez vous vÃ©rifiez que rien n'a Ã©tÃ© compromis ?

`openssl s_client -verify_quiet -quiet -connect malware.serviel.fr:1234`

ğŸ’½ binaire : 2_chal

ğŸ•µï¸â€â™€ï¸ Dans la function main, on retrouve la crÃ©ation d'un fichier de log ("/tmp/keys.log") et deux fonctions Ã  reverser (1 et 2)

![](attachment/3ecda689b40a11484523f55b7b152508.png)

##### Function 1

![](attachment/b22c2f0b485cec3c0dae98e72057a003.png)

ioctl : La fonctionÂ **ioctl**() modifie le comportement des pÃ©riphÃ©riques sous-jacents des fichiers spÃ©ciaux. En particulier, de nombreuses caractÃ©ristiques des fichiers spÃ©ciaux en mode caractÃ¨re (par exemple des terminaux) peuvent Ãªtre contrÃ´lÃ©es avec des requÃªtesÂ **ioctl**().

ğŸ•µï¸â€â™€ï¸ cette fonction semble manipuler le comportement des pÃ©riphÃ©riques des fichiers spÃ©ciaux contenus dans /dev/input :

![](attachment/a6fa5077b62461bc7d608d8cf25755b0.png)
Le rÃ©pertoire `/dev/input` sous Linux contient des fichiers de pÃ©riphÃ©riques liÃ©s aux **entrÃ©es utilisateur**, comme les claviers, souris, Ã©crans tactiles, et autres dispositifs d'entrÃ©e.

ğŸ•µï¸â€â™€ï¸ Cette fonction en recherche un pÃ©riphÃ©rique d'entrÃ©e spÃ©cifique dans le rÃ©pertoireÂ `/dev/input/`, vÃ©rifie ses caractÃ©ristiques Ã  l'aide des appels ioctl, puis renvoie le chemin du pÃ©riphÃ©rique trouvÃ© sous forme de chaÃ®ne de caractÃ¨res. D'aprÃ¨s des recherches internet, on peut supposer que le pÃ©riphÃ©rique recherchÃ© est un clavier ou une souris.

ğŸ•µï¸â€â™€ï¸ Ã‡a Ã  tout l'air d'un keylogger !

##### Function 2

ğŸ•µï¸â€â™€ï¸ Ici tant qu'on n'envoie pas une interruption de type "CTRL + C" Le keyloger continue de logger

![](attachment/da845d5d57d360057fde30cda49bb430.png)

![](attachment/638ddedc2a9981dba424615107192556.png)

#### Exploitation

ğŸ•µï¸â€â™€ï¸ Le fonctionnement du programme est assez simple Ã  comprendre, il enregistre des entrÃ©es utilisateur et les Ã©crits dans "/tmp/keys.log"

ğŸ•µï¸â€â™€ï¸ Si on lance le binaire, on retrouve bien le fichier de logs :

![](attachment/6097055843d85171f44811b41cefa72b.png)

ğŸ•µï¸â€â™€ï¸ En revanche, le contenu est illisible : 

![](attachment/98b9ba37f914511ee00950a986da587f.png)



ğŸ•µï¸â€â™€ï¸ Et c'est normal ! Dans le prochain paragraphe on va expliquer pourquoi (attention Ã§a pique un peu !) :

##### How input works
â„¹ï¸ Pour la dÃ©monstration, nous allons prendrles entrÃ©esÃ©e du clavier

ğŸ’¡ X11 (https://en.wikipedia.org/wiki/X_Window_System#Software_architecture) lit les entrÃ©es du clavier depuis le kernel, les parses et leutilisentts poudiverses applicationses.

ğŸ’¡ Les sources d'inputs x11 sont appelÃ©s "event" et sont stockÃ©s dans "/dev/input" (clavier, souris, joystick etc...). D'ailleurs, voupouvez allerez y jeter un oeil sur votre ordinateur : 

![](attachment/908b8ad9b60f4e25d9c5e060dd6cd103.png)

ğŸ’¡ Mais comment je peux savoir quel event et liÃ© Ã  quel input ? Il faut aller voir les fichier dans /proc/bus/input/devices : 

```bash
less /proc/bus/input/devices 
```

![](attachment/c13f1158108adc39b053c1a8e93e8a98.png)

Ici Ã§a sera l'event 1 pour mes entrÃ©es clavier ! On peut d'ailleurs faire le test pour voir les donnÃ©es Ã©crites. En faisant le test on se rend compte qu'il capture aussi bien au moment oÃ¹ on appuit sur le touche mais aussi quand on relÃ¢che la touche ! :

![](attachment/071413d8ccb339d8c2500a4ff4051e3d.png)

ğŸ•µï¸â€â™‚ï¸ Si on suit la documentation linux on sait qu'un input stream Ã  le format suivant : 

```c
struct input_event {
	struct timeval time; //timestamp sur 16 bytes
	unsigned short type; //type de l'event sur 2 bytes
	unsigned short code; // code de la touche sur 2 bytes
	unsigned int value; // Etat de la touche (pressÃ©e, relachÃ©e, rÃ©pÃ©tÃ©e) sur 4 bytes
};

struct timeval{
	time_t tv_sec; /* uint64 - Seconds since the epoch */ 
	suseconds_t tv_usec; /* uint64 - Micro seconds */
}
```

**Total size**Â = 24 bytes

ğŸ•µï¸â€â™‚ï¸ D'oÃ¹ l'Ã©criture de chunk de 24 bytes dans le code du keylogger. 

ğŸ•µï¸â€â™‚ï¸ Si l'on souhaite connaitre les valeurs de ces types, codes et key values, on peut aller voir le code source de linux : 

- Event types : https://github.com/torvalds/linux/blob/8096acd7442e613fad0354fc8dfdb2003cceea0b/include/uapi/linux/input-event-codes.h#L35
- Event codes : https://www.kernel.org/doc/Documentation/input/event-codes.txt avec les correspondance en valeur https://github.com/torvalds/linux/blob/8096acd7442e613fad0354fc8dfdb2003cceea0b/include/uapi/linux/input-event-codes.h#L75-L338
- Key values : is the value the event carries. Either a relative change forÂ `EV_REL`, absolute new value forÂ `EV_ABS`Â (joysticks ...), or 0 forÂ `EV_KEY`Â for release, ==1 for key-press== and 2 for autorepeat.

On peut Ã©galement avoir des informations trÃ©s dÃ©taillÃ©es sur toutes les valeurs de cette structure dans la documentation du noyau linux : 
https://www.kernel.org/doc/html/v4.18/input/event-codes.html ğŸ˜

ğŸ’¡Ce qui nous intÃ©resse dans le cadre des inputs keyboard :

- ==Event type== : 

![](attachment/d867539b3109d4335c7e6428197ca1d8.png)

- ==Event codes== : Ici ce sont diffÃ©rentes valeurs que peuvent prendre les "Event type". C'est sur cette valeur qu'on va pouvoir avoir quelle touche a Ã©tÃ© enfoncÃ©e :

![](attachment/fc44e1b390ad81270a8a78124f7ffcec.png)

![](attachment/8796c55bb4379e3ff2d82407ed842a25.png)

 ![](attachment/35f85b52c9c601ac31a866760f3dcda9.png)
 
- ==Key Value== : Ici Ã§a va nous permettre de sÃ©lectionne uniquement les touches qui ont Ã©tÃ© "pressÃ©es"  

![](attachment/06374648a15ebd1262db83cb46b01c83.png)

ğŸ•µï¸â€â™‚ï¸ Maintenant qu'on a compris le fonctionnement global, nous allons Ã©crire un script pour voir si on a compris.

ğŸ•µï¸â€â™‚ï¸ Pour ce faire, nous allons gÃ©nÃ©rer des logs avec les entrÃ©es A - B - C -D - E

![](attachment/9e9d5fb8cd1bcc79a6e618597e40f847.png)

ğŸ•µï¸â€â™€ï¸ DÃ©jÃ , on remarque bien un pattern qui se rÃ©pÃ¨te tous les 24 bytes : 

![](attachment/921ac1ff26a1454f5e8adaee6f8e3713.png)


ğŸ•µï¸â€â™€ï¸ Vu que chaque input est Ã©crit sur un total de 24 bytes, nous allons parcourir le fichier 24bytes par 24 bytes,
ğŸ•µï¸â€â™€ï¸  Et ce, suivant la structure qu'on avait dÃ©fini plus tÃ´t on a  :

```c
struct input_event {
	struct timeval time; -> 0891 6794 0000 0000 (16 bytes)
	unsigned short type; -> 0004 (2bytes)
	unsigned short code; -> 0004 (2bytes)
	unsigned int value; -> 0000002a (4bytes) = 42 -> 
};
struct timeval{
	time_t tv_sec; -> 0000000067940891
	suseconds_t tv_usec; -> 000bdf5300000000
}
```

ğŸ•µï¸â€â™€ï¸ On peut dÃ©jÃ  Ã©crire un script qui va extraire les events types = 0x1 qui sont liÃ©es aux evÃ©vÃ©nements clavier : 

![](attachment/a30014b3bf99b6c94ebeceea693050e2.png)

ğŸ•µï¸â€â™€ï¸ Pour 1 la value est 30 (0x1e) et B la value est 48 (0x30)

![](attachment/40272e7be5c8557b6fde407c219b1b00.png)

```python
import struct

def main():
    keylog_file_path = "./keyboard_test.log"

    with open(keylog_file_path,"rb") as file:
        while True:
            try:
                data = file.read(24)          
                data = struct.unpack('4IHHI', data) # 4I -> 4 int, HH -> 2 short, un int
                
                """ 
                Suivant la structure ci-dessous, il nous reste plus qu'Ã  extraire chaque valeur
                    struct input_event {
                struct timeval time; //timestamp sur 16 bytes
                unsigned short type; //type de l'event sur 2 bytes
                unsigned short code; // code de la touche sur 2 bytes
                unsigned int value; // Etat de la touche (pressÃ©e, relachÃ©e, rÃ©pÃ©tÃ©e) sur 4 bytes
            }; """

                timestamp = data[0] # Le premier int de timevale c'est le timestamp en secondes
                input_type = data[4] # si = 1 -> Keyboard event
                input_code = data[5] # Il faut lire les valeurs pour connaitre leurs correspondances
                input_value = data[6] # si = 1 -> key pressed
        
                if input_type == 1 and input_value == 1 and input_code == 48 : # je vÃ©rifie si c'est Ã©gale Ã  'B' 
                    print(timestamp)
                    print(input_type)
                    print(input_code)
                    print(input_value)
            except Exception as e:
                 break
           
if __name__ == '__main__':
    main()
```

Et on retrouve bien la touche B qui a Ã©tÃ© pressÃ©e :

![](attachment/3cdf05e181e8e01ddcbe05d35643e8de.png)

ğŸ•µï¸â€â™€ï¸ Par contre pour le A, par dÃ©faut, il il se base sur un clavier qwerty, du coup au lieu du A il a reconnu un Q !!! Il va falloir adapter Ã§a dans notre code.

```python
import struct
from datetime import datetime

code_dict_qwerty = {
    0: '[RESERVED]',
    1: '[ESC]',
    2: '1',
    3: '2',
    4: '3',
    5: '4',
    6: '5',
    7: '6',
    8: '7',
    9: '8',
    10: '9',
    11: '0',
    12: '-',
    13: '=',
    14: '[BACKSPACE]',
    15: '[TAB]',
    16: 'q',
    17: 'w',
    18: 'e',
    19: 'r',
    20: 't',
    21: 'y',
    22: 'u',
    23: 'i',
    24: 'o',
    25: 'p',
    26: '^',
    27: '$',
    28: '[ENTER]\n',
    29: '[L_CTRL]',
    30: 'a',
    31: 's',
    32: 'd',
    33: 'f',
    34: 'g',
    35: 'h',
    36: 'j',
    37: 'k',
    38: 'l',
    39: ';',
    40: '!',
    41: '`',
    42: '[L_SHIFT]',
    43: '\\',
    44: 'z',
    45: 'x',
    46: 'c',
    47: 'v',
    48: 'b',
    49: 'n',
    50: 'm',
    51: ',',
    52: '.',
    53: '/',
    54: '[R_SHIFT]',
    55: '*',
    56: '[L_ALT]',
    57: ' ',
    58: '[CAPSLOCK]',
    59: '[F1]',
    60: '[F2]',
    61: '[F3]',
    62: '[F4]',
    63: '[F5]',
    64: '[F6]',
    65: '[F7]',
    66: '[F8]',
    67: '[F9]',
    68: '[F10]',
    69: '[NUMLOCK]',
    70: '[SCROLLLOCK]',
    71: '7',
    72: '8',
    73: '9',
    74: '-',
    75: '4',
    76: '5',
    77: '6',
    78: '+',
    79: '1',
    80: '2',
    81: '3',
    82: '0',
    83: '.',
    84: '',
    85: '[ZENKAKUHANKAKU]',
    86: '<',
    87: '[F11]',
    88: '[F12]',
    89: '[RO]',
    90: '[KATAKANA]',
    91: '[HIRAGANA]',
    92: '[HENKAN]',
    93: '[KATAKANAHIRAGANA]',
    94: '[MUHENKAN]',
    95: '[KPJPCOMMA]',
    96: '[ENTER]\n',
    97: '[R_CTRL]',
    98: '[KPSLASH]',
    99: '[SYSRQ]',
    100: '[R_ALT]',
    101: '[LINEFEED',
    102: '[HOME]',
    103: '[UP]',
    104: '[PAGEUP]',
    105: '[LEFT]',
    106: '[RIGHT]',
    107: '[END]',
    108: '[DOWN]',
    109: '[PAGEDOWN]',
    110: '[INSERT]',
    111: '[DEL]',
    112: '[MACRO]',
    113: '[MUTE]',
    114: '[VOLUMEDOWN]',
    115: '[VOLUMEUP]',
    116: '[POWER]',
    117: '[KPEQUAL]',
    118: '[KPPLUSMINUS]',
    119: '[PAUSE]',
    120: '[SCALE]',
    121: '[KPCOMMA]',
    122: '[HANGEUL]',
    123: '[HANJA]',
    124: '[YEN]',
    125: '[LEFTMETA]',
    126: '[RIGHTMETA]',
    127: '[COMPOSE]',
    128: '[STOP]',
    129: '[AGAIN]',
    130: '[PROPS]',
    131: '[UNDO]',
    132: '[FRONT]',
    133: '[COPY]',
    134: '[OPEN]',
    135: '[PASTE]',
    136: '[FIND]',
    137: '[CUT]',
    138: '[HELP]',
    139: '[MENU]',
    140: '[CALC]',
    141: '[SETUP]',
    142: '[SLEEP]',
    143: '[WAKEUP]',
    144: '[FILE]',
    145: '[SENDFILE]',
    146: '[DELETEFILE]',
    147: '[XFER]',
    148: '[PROG1]',
    149: '[PROG2]',
    150: '[WWW]',
    151: '[MSDOS]',
    152: '[SCREENLOCK]',
    153: '[ROTATE_DISPLAY]',
    154: '[CYCLEWINDOWS]',
    155: '[MAIL]',
    156: '[BOOKMARKS]',
    157: '[COMPUTER]',
    158: '[BACK]',
    159: '[FORWARD]',
    160: '[CLOSECD]',
    161: '[EJECTCD]',
    162: '[EJECTCLOSECD]',
    163: '[NEXTSONG]',
    164: '[PLAYPAUSE]',
    165: '[PREVIOUSSONG]',
    166: '[STOPCD]',
    167: '[RECORD]',
    168: '[REWIND]',
    169: '[PHONE]',
    170: '[ISO]',
    171: '[CONFIG]',
    172: '[HOMEPAGE]',
    173: '[REFRESH]',
    174: '[EXIT]',
    175: '[MOVE]',
    176: '[EDIT]',
    177: '[SCROLLUP]',
    178: '[SCROLLDOWN]',
    179: '[KPLEFTPAREN]',
    180: '[KPRIGHTPAREN]',
    181: '[NEW]',
    182: '[REDO]',
    183: '[F13]',
    184: '[F14]',
    185: '[F15]',
    186: '[F16]',
    187: '[F17]',
    188: '[F18]',
    189: '[F19]',
    190: '[F20]',
    191: '[F21]',
    192: '[F22]',
    193: '[F23]',
    194: '[F24]',
    195: '',
    196: '',
    197: '',
    198: '',
    199: '',
    200: '[PLAYCD]',
    201: '[PAUSECD]',
    202: '[PROG3]',
    203: '[PROG4]',
    204: '[ALL_APPLICATIONS]',
    205: '[SUSPEND]',
    206: '[CLOSE]',
    207: '[PLAY]',
    208: '[FASTFORWARD]',
    209: '[BASSBOOST]',
    210: '[PRINT]',
    211: '[HP]',
    212: '[CAMERA]',
    213: '[SOUND]',
    214: '[QUESTION]',
    215: '[EMAIL]',
    216: '[CHAT]',
    217: '[SEARCH]',
    218: '[CONNECT]',
    219: '[FINANCE]',
    220: '[SPORT]',
    221: '[SHOP]',
    222: '[ALTERASE]',
    223: '[CANCEL]',
    224: '[BRIGHTNESSDOWN]',
    225: '[BRIGHTNESSUP]',
    226: '[MEDIA]',
    227: '[SWITCHVIDEOMODE]',
    228: '[KBDILLUMTOGGLE]',
    229: '[KBDILLUMDOWN]',
    230: '[KBDILLUMUP]',
    231: '[SEND]',
    232: '[REPLY]',
    233: '[FORWARDMAIL]',
    234: '[SAVE]',
    235: '[DOCUMENTS]',
    236: '[BATTERY]',
    237: '[BLUETOOTH]',
    238: '[WLAN]',
    239: '[UWB]',
    240: '[UNKNOWN]',
    241: '[VIDEO_NEXT]',
    242: '[VIDEO_PREV]',
    243: '[BRIGHTNESS_CYCLE]',
    244: '[BRIGHTNESS_AUTO]',
    245: '[DISPLAY_OFF]',
    246: '[WWAN]',
    247: '[RFKILL]',
    248: '[MICMUTE]'
}
azerty = 'Â²&Ã©"\'(-Ã¨_Ã§Ã )=azertyuiop^$qsdfghjklmÃ¹*<wxcvbn,;:!1234567890'

def main():
    keylog_file_path = "./keyboard_test.log"
   
    result = []
    begining_keylog = ""
    readable_date = ""
    with open(keylog_file_path,"rb") as file:
        while True:
            try:
                data = file.read(24)
                data = struct.unpack('4IHHI', data) # 4I -> 4 int, HH -> 2 short, un int
                timestamp = data[0]
                
                if not timestamp:
                    break
                input_type = data[4]
                input_code = data[5]
                input_value = data[6]
        
                
                if  begining_keylog == "":
                    dt_object = datetime.fromtimestamp(timestamp)
                    readable_date = dt_object.strftime('%Y-%m-%d %H:%M:%S')
                
                if  input_type == 1 and input_value == 1 and code_dict_qwerty[input_code] in azerty: 
                    
                    key = code_dict_qwerty[input_code]
                    result.append(key)
                        
            except Exception as e:
                 break
    
    
    print("DÃ©but du keylogging : " + readable_date + "\n")
    print("qwerty_us : " + ''.join(result))
  

   
if __name__ == '__main__':
    main()
```

![](attachment/b214ec0c00ac31647074d9d92a07a868.png)

ğŸ•µï¸â€â™€ï¸ Nickel, notre code a l'air de bien fonctionner. On n'a plus qu'Ã  le tester sur notre chall : 

![](attachment/5070127f597886ef2bc191c23fd43fa8.png)

ğŸ¤¡ How noooo, Ã§a ne marche pas. Ã‡a ne doit pas Ãªtre un clavier qwerty...

ğŸ•µï¸â€â™€ï¸ Nous avons redÃ©fini plusieurs "keyboard layout" : 

```python
keyboard_layouts = {
    
    "qwerty_us": '`1234567890-=qwertyuiop[]asdfghjkl;\'\\\\zxcvbnm,./',
    "qwerty_uk": '`1234567890-=qwertyuiop[]asdfghjkl;\'#\\zxcvbnm,./',
    "azerty_fr": 'Â²&Ã©"\'(-Ã¨_Ã§Ã )=azertyuiop^$qsdfghjklmÃ¹*<wxcvbn,;:!',
    "azerty_belgique": 'Â²&Ã©"\'(Â§Ã¨!Ã§Ã )-azertyuiop^$qsdfghjklmÃ¹Âµ<wxcvbn,;:=',
    "azerty_canada": "`1234567890-=azertyuiop^qsdfghjklmÃ¹*wxcvbn,;:!##",
    "qwertz_de": "`1234567890-=qwertzuiopÃ¼+asdfghjklÃ¶Ã¤#<yxcvbnm,.-",
    "qwertz_ch": "Â°1234567890'=qwertzuiopÃ¼Â¨asdfghjklÃ¶Ã¤$<yxcvbnm,.-",
    "azerty_lux": "Â²&Ã©\"'(-Ã¨_Ã§Ã )=azertyuiop^qsdfghjklmÃ¹*wxcvbn,;:!##",
}

```

ğŸ•µï¸â€â™€ï¸ Final code :

```python
import binascii
from datetime import datetime
from pwn import *

keyboard_layouts = {
    
    "qwerty_us": '`1234567890-=qwertyuiop[]asdfghjkl;\'\\\\zxcvbnm,./',
    "qwerty_uk": '`1234567890-=qwertyuiop[]asdfghjkl;\'#\\zxcvbnm,./',
    "azerty_fr": 'Â²&Ã©"\'(-Ã¨_Ã§Ã )=azertyuiop^$qsdfghjklmÃ¹*<wxcvbn,;:!',
    "azerty_belgique": 'Â²&Ã©"\'(Â§Ã¨!Ã§Ã )-azertyuiop^$qsdfghjklmÃ¹Âµ<wxcvbn,;:=',
    "azerty_canada": "`1234567890-=azertyuiop^qsdfghjklmÃ¹*wxcvbn,;:!##",
    "qwertz_de": "`1234567890-=qwertzuiopÃ¼+asdfghjklÃ¶Ã¤#<yxcvbnm,.-",
    "qwertz_ch": "Â°1234567890'=qwertzuiopÃ¼Â¨asdfghjklÃ¶Ã¤$<yxcvbnm,.-",
    "azerty_lux": "Â²&Ã©\"'(-Ã¨_Ã§Ã )=azertyuiop^qsdfghjklmÃ¹*wxcvbn,;:!##",
}

code_dict_qwerty = {
    0: '[RESERVED]',
    1: '[ESC]',
    2: '1',
    3: '2',
    4: '3',
    5: '4',
    6: '5',
    7: '6',
    8: '7',
    9: '8',
    10: '9',
    11: '0',
    12: '-',
    13: '=',
    14: '[BACKSPACE]',
    15: '[TAB]',
    16: 'q',
    17: 'w',
    18: 'e',
    19: 'r',
    20: 't',
    21: 'y',
    22: 'u',
    23: 'i',
    24: 'o',
    25: 'p',
    26: '^',
    27: '$',
    28: '[ENTER]\n',
    29: '[L_CTRL]',
    30: 'a',
    31: 's',
    32: 'd',
    33: 'f',
    34: 'g',
    35: 'h',
    36: 'j',
    37: 'k',
    38: 'l',
    39: ';',
    40: '!',
    41: '`',
    42: '[L_SHIFT]',
    43: '\\',
    44: 'z',
    45: 'x',
    46: 'c',
    47: 'v',
    48: 'b',
    49: 'n',
    50: 'm',
    51: ',',
    52: '.',
    53: '/',
    54: '[R_SHIFT]',
    55: '*',
    56: '[L_ALT]',
    57: ' ',
    58: '[CAPSLOCK]',
    59: '[F1]',
    60: '[F2]',
    61: '[F3]',
    62: '[F4]',
    63: '[F5]',
    64: '[F6]',
    65: '[F7]',
    66: '[F8]',
    67: '[F9]',
    68: '[F10]',
    69: '[NUMLOCK]',
    70: '[SCROLLLOCK]',
    71: '7',
    72: '8',
    73: '9',
    74: '-',
    75: '4',
    76: '5',
    77: '6',
    78: '+',
    79: '1',
    80: '2',
    81: '3',
    82: '0',
    83: '.',
    84: '',
    85: '[ZENKAKUHANKAKU]',
    86: '<',
    87: '[F11]',
    88: '[F12]',
    89: '[RO]',
    90: '[KATAKANA]',
    91: '[HIRAGANA]',
    92: '[HENKAN]',
    93: '[KATAKANAHIRAGANA]',
    94: '[MUHENKAN]',
    95: '[KPJPCOMMA]',
    96: '[ENTER]\n',
    97: '[R_CTRL]',
    98: '[KPSLASH]',
    99: '[SYSRQ]',
    100: '[R_ALT]',
    101: '[LINEFEED',
    102: '[HOME]',
    103: '[UP]',
    104: '[PAGEUP]',
    105: '[LEFT]',
    106: '[RIGHT]',
    107: '[END]',
    108: '[DOWN]',
    109: '[PAGEDOWN]',
    110: '[INSERT]',
    111: '[DEL]',
    112: '[MACRO]',
    113: '[MUTE]',
    114: '[VOLUMEDOWN]',
    115: '[VOLUMEUP]',
    116: '[POWER]',
    117: '[KPEQUAL]',
    118: '[KPPLUSMINUS]',
    119: '[PAUSE]',
    120: '[SCALE]',
    121: '[KPCOMMA]',
    122: '[HANGEUL]',
    123: '[HANJA]',
    124: '[YEN]',
    125: '[LEFTMETA]',
    126: '[RIGHTMETA]',
    127: '[COMPOSE]',
    128: '[STOP]',
    129: '[AGAIN]',
    130: '[PROPS]',
    131: '[UNDO]',
    132: '[FRONT]',
    133: '[COPY]',
    134: '[OPEN]',
    135: '[PASTE]',
    136: '[FIND]',
    137: '[CUT]',
    138: '[HELP]',
    139: '[MENU]',
    140: '[CALC]',
    141: '[SETUP]',
    142: '[SLEEP]',
    143: '[WAKEUP]',
    144: '[FILE]',
    145: '[SENDFILE]',
    146: '[DELETEFILE]',
    147: '[XFER]',
    148: '[PROG1]',
    149: '[PROG2]',
    150: '[WWW]',
    151: '[MSDOS]',
    152: '[SCREENLOCK]',
    153: '[ROTATE_DISPLAY]',
    154: '[CYCLEWINDOWS]',
    155: '[MAIL]',
    156: '[BOOKMARKS]',
    157: '[COMPUTER]',
    158: '[BACK]',
    159: '[FORWARD]',
    160: '[CLOSECD]',
    161: '[EJECTCD]',
    162: '[EJECTCLOSECD]',
    163: '[NEXTSONG]',
    164: '[PLAYPAUSE]',
    165: '[PREVIOUSSONG]',
    166: '[STOPCD]',
    167: '[RECORD]',
    168: '[REWIND]',
    169: '[PHONE]',
    170: '[ISO]',
    171: '[CONFIG]',
    172: '[HOMEPAGE]',
    173: '[REFRESH]',
    174: '[EXIT]',
    175: '[MOVE]',
    176: '[EDIT]',
    177: '[SCROLLUP]',
    178: '[SCROLLDOWN]',
    179: '[KPLEFTPAREN]',
    180: '[KPRIGHTPAREN]',
    181: '[NEW]',
    182: '[REDO]',
    183: '[F13]',
    184: '[F14]',
    185: '[F15]',
    186: '[F16]',
    187: '[F17]',
    188: '[F18]',
    189: '[F19]',
    190: '[F20]',
    191: '[F21]',
    192: '[F22]',
    193: '[F23]',
    194: '[F24]',
    195: '',
    196: '',
    197: '',
    198: '',
    199: '',
    200: '[PLAYCD]',
    201: '[PAUSECD]',
    202: '[PROG3]',
    203: '[PROG4]',
    204: '[ALL_APPLICATIONS]',
    205: '[SUSPEND]',
    206: '[CLOSE]',
    207: '[PLAY]',
    208: '[FASTFORWARD]',
    209: '[BASSBOOST]',
    210: '[PRINT]',
    211: '[HP]',
    212: '[CAMERA]',
    213: '[SOUND]',
    214: '[QUESTION]',
    215: '[EMAIL]',
    216: '[CHAT]',
    217: '[SEARCH]',
    218: '[CONNECT]',
    219: '[FINANCE]',
    220: '[SPORT]',
    221: '[SHOP]',
    222: '[ALTERASE]',
    223: '[CANCEL]',
    224: '[BRIGHTNESSDOWN]',
    225: '[BRIGHTNESSUP]',
    226: '[MEDIA]',
    227: '[SWITCHVIDEOMODE]',
    228: '[KBDILLUMTOGGLE]',
    229: '[KBDILLUMDOWN]',
    230: '[KBDILLUMUP]',
    231: '[SEND]',
    232: '[REPLY]',
    233: '[FORWARDMAIL]',
    234: '[SAVE]',
    235: '[DOCUMENTS]',
    236: '[BATTERY]',
    237: '[BLUETOOTH]',
    238: '[WLAN]',
    239: '[UWB]',
    240: '[UNKNOWN]',
    241: '[VIDEO_NEXT]',
    242: '[VIDEO_PREV]',
    243: '[BRIGHTNESS_CYCLE]',
    244: '[BRIGHTNESS_AUTO]',
    245: '[DISPLAY_OFF]',
    246: '[WWAN]',
    247: '[RFKILL]',
    248: '[MICMUTE]'
}

def generate_output_for_other_layout(output_string):

    translations = {}
    for layout_name, layout_keys in keyboard_layouts.items():
        if layout_name != "qwerty_us":  # On ne traduit pas vers lui-mÃªme
            translations[layout_name] = str.maketrans(keyboard_layouts["qwerty_us"], layout_keys)
    for layout, translation in translations.items():
        translated = output_string.translate(translation)
       
        print(f"{layout}: {translated}")



def main():
    keylog_file_path = "./keys.log"
   
    result = []
    begining_keylog = ""
    readable_date = ""
    with open(keylog_file_path,"rb") as file:
        while True:
            try:
                data = file.read(24)
                data = struct.unpack('4IHHI', data) # 4I -> 4 int, HH -> 2 short, un int
                timestamp = data[0]
                
                if not timestamp:
                    break
                input_type = data[4]
                input_code = data[5]
                input_value = data[6]
        
                
                if  begining_keylog == "":
                    dt_object = datetime.fromtimestamp(timestamp)
                    readable_date = dt_object.strftime('%Y-%m-%d %H:%M:%S')
                
                if  input_type == 1 and input_value == 1 and code_dict_qwerty[input_code] in keyboard_layouts["azerty_fr"]: 
                    
                    key = code_dict_qwerty[input_code]
                    result.append(key)
                        
            except Exception as e:
                 break

    
    print("DÃ©but du keylogging : " + readable_date + "\n")
    print("qwerty_us : " + ''.join(result))
    generate_output_for_other_layout(''.join(result))

   
if __name__ == '__main__':
    main()
```

![](attachment/b259fbe51197f04ea8ec90813643f23a.png)

ğŸ‡ğŸ‡ C'est gagnÃ©
### Packer

>consigne : Je ne comprends pas ce binaire, le code executÃ© n'as pas l'air de correspondre Ã  ce que je reverse

ğŸ’½ binaire : 3_chall

ğŸ•µï¸â€â™€ï¸ AprÃ¨s avoir fait le travail de renommage et retypage, nous avons une fonction main assez simple Ã  comprendre : 

![](attachment/e1c24becc079e584738a6f37681a5bf6.png)

1) On Ã©crit les bytes contenus dans "data" dans le fichier "/tmp/toto",
2) On rend /tmp/toto executable (0x49 -> 0111 -> permissoins d'exÃ©cution sur 'propriÃ©taire' 'groupe' 'autre')
3) On exÃ©cute /tmp/toto

â„¹ï¸ C'est pour Ã§a que quand on lance le programme principal, on a un output totalement Ã©trange. C'est parce que le code principal est dans toto !!!
![](attachment/24b614c58caef62eed9d4ee5a42f7c27.png)

ğŸ•µï¸â€â™€ï¸ Le problÃ¨me, c'est qu'on ne peut pas rÃ©cupÃ©rer le fichier toto ! Une fois lancÃ©, il est supprimÃ©. Il existe deux mÃ©thodes pour le rÃ©cupÃ©rer. Soit en dynamique (plus rapide), soit en statique. Ici, je vais opter pour l'option statique.


#### Unpacking

```python
from pwn import *

def main():
    elf = ELF('./3_chal')

    data_addr = elf.symbols['data']
    data_value = elf.read(data_addr, 0x2198)
    print(data_value)
if __name__ == '__main__':
    main()
```

ğŸ•µï¸â€â™€ï¸ Ici, on voit dans la donnÃ©e extraite qu'on a un header ELF et on retrouve des strings qu'on avait vu dans l'exÃ©cution du programme : 

![](attachment/449399f4f0af83127cf30f3807e15a8d.png)
![](attachment/219d47bbc2207b54e4e337a4a8da80b1.png)

ğŸ•µï¸â€â™€ï¸ Ã‰crivons cette donnÃ©e dans un fichier : 

```python
from pwn import *

def main():
    elf = ELF('./3_chal')

    data_addr = elf.symbols['data']
    data_value = elf.read(data_addr, 0x2198)

    path_unpack = "./unpack.bin"
    with open(path_unpack,"wb") as file :
        file.write(data_value)

if __name__ == '__main__':
    main()
```

ğŸ•µï¸â€â™€ï¸ On confirme qu'il s'agit d'un binaire exÃ©cutablee de type ELF : 

![](attachment/2a3e7f4992756a388014a1cad0c38c31.png)

#### Reverse du binaire unpacked

ğŸ•µï¸â€â™€ï¸ Une fois chargÃ© dans IDA, on retrouve bien du code Ã  reverse !!!

![](attachment/2f59986bb9719a31951aeba05b06a933.png)

ğŸ•µï¸â€â™€ï¸ Explication sur ce code : 

![](attachment/e057bee83da028eb40a8bb87040a72f7.png)

1) L'utilisateur rentre un input,
2) On xor cet input avec la clÃ©e (0xAA)
3) On compare chaque byte avec les bytes prÃ©sents dans la variable "byte_402000"

ğŸ•µï¸â€â™€ï¸ Il nous reste plus qu'a instrumenter tout Ã§a pour retrouver le flag !!

```python
from pwn import *
import os

def main():
    path_unpack = "./unpack.bin"
    XOR_KEY = 0xAA
    result=[]

    elf = ELF('./3_chal')

    data_addr = elf.symbols['data']
    data_value = elf.read(data_addr, 0x2198)

    
    with open(path_unpack,"wb") as file :
        file.write(data_value)
    os.chmod(path_unpack, 0o755)

    elf = ELF(path_unpack)
    data_to_match = elf.read(0x402000,0x18)
    for byte in data_to_match:
        xor_value = byte ^ XOR_KEY
        result.append(chr(xor_value))
    
    print(''.join(result))
    
    #io.sendlineafter("Input: ")
if __name__ == '__main__':
    main()
```

![](attachment/2d06175ba593385fb0c253bbe70f4b17.png)

ğŸ‡ You win !
### VM

>consigne : L'objectif est simpleÂ : trouver l'entrÃ©e qui permet d'afficher "gagne"

>Le flag est ensuite: HackUTT{le mdp trouvÃ©}

ğŸ’½ binaire : 4_chall

#### IdÃ©e gÃ©nÃ©rale :

ğŸ•µï¸â€â™€ï¸ La premiÃ¨re idÃ©e, c'est de comprendre comment la vm est crÃ©Ã©e
ğŸ•µï¸â€â™€ï¸ Elle va gÃ©nÃ©ralement crÃ©er : des registres, une stack, des instructions
ğŸ•µï¸â€â™€ï¸ Une fois que tu as toutes ces informations, tu pourras crÃ©er une structure. Ã‡a va te faciliter l'analyse !!!

ğŸ’¡ En retour d'expÃ©rience, il est important d'identifier oÃ¹ est le code de la VM, oÃ¹ sera notre eip (gÃ©nÃ¨ralement il sera en dÃ©but de switch case), oÃ¹ sera placÃ©e la stack de la VM (voir la fonction d'initialisation). Ensuite pour comprendre les instructions, j'ai fait Ã©normÃ©ment de test et de debug avec GDB. 
#### Analyse

##### Initialisation de la vm

ğŸ•µï¸â€â™€ï¸ Nous avons de la chance, la fonction main est explicite :

![](attachment/70cd33b59b5c6d09a5404003c95cfc6c.png)

Il est important de comprendre comment la VM est crÃ©Ã©e.

ğŸ•µï¸â€â™€ï¸ Nous avons une allocation d'un bloc mÃ©moire de 0x12D0

![](attachment/b87334946c251fb401dfd32640cc605b.png)

ğŸ•µï¸â€â™€ï¸ Ensuite on remplit cette espace mÃ©moire :

![](attachment/a39a4948d1b5ff6a5b69a0ef96827212.png)

1) Ajout l'adresse de la data nommÃ© '0xA' dans la premiÃ¨re adresse du buffer (on verra plus tard qu'il s'agit du code de la VM),
2) Ajout de 0x54 dans la troisiÃ¨me adresse du buffer,
3) Le buffer est rempli 100 fois par des adresses pointant vers des buffer de taille 0x2C.

Ici nous avons l'initialisation de plusieurs buffer pour le bon fonctionnement de la VM ! 

Maintenant qu'on connait la structure globale, nous allons pouvoir crÃ©er une structure ! 

![](attachment/5d2e983dfd85632c27b8c79775ad1d48.png)

![](attachment/4a59e537c482ee31e7db1c25ae9c1a23.png)

![](attachment/3e87cd455625adf3df58eca3261945c5.png)

![](attachment/007a3e0e89d16792dd0639e1b0f09990.png)

![](attachment/e647ad1b9b5b5eb9d3110d9ffe481f8b.png)

ğŸ•µï¸â€â™€ï¸ Maintenant, nous pouvons retyper toutes les rÃ©fÃ©rences au buffer de 0x12D0 qui contient l'ensemble de la VM : 

![](attachment/af378ff95bbac2fafc61b64e0e9bc724.png)

On observe dÃ©jÃ  que Ã§a devient beaucoup plus lisible :

![](attachment/1776ff6c887d5e763aedaebd8f081a78.png)
##### Execution de la VM

ğŸ•µï¸â€â™€ï¸ Nous allons nous rendre dans la fonction "vm_exec" afin de comprendre, ou sera placÃ©e la stack, les registres etc..

ğŸ•µï¸â€â™€ï¸ On a un grand switch case qui suivant la valeur donnÃ©e va exÃ©cuter des intructions. On remarque Ã©galement un pattern avec des opÃ©rations diffÃ©rentes suivant le case (+, -, *, < etc ... ) :

![](attachment/579729a4758076542f2610cca990f960.png)

ğŸ•µï¸â€â™€ï¸ Il se passe plusieurs choses intÃ©ressantes. D'abord, on a une grande boucle. C'est elle qui semble rÃ©cupÃ©rer les instructions pour les passer dans les cases. On pourrait dire qu'il s'agit d'EIP (le pointeur d'instruction):

![](attachment/12ffe6939a02fab2388fdfd4fcf4dd4a.png)

ğŸ•µï¸â€â™€ï¸ Dans chaque case, on place des valeurs dans des variables (qui seront certainement des registres de la VM) ces valeurs proviennent, probablement, de la stack  car celle-ci est souvent dÃ©crÃ©mentÃ©e avant chaque calcul : 

![](attachment/fcdf0043828c074e5bc6210338ca0543.png)

ğŸ•µï¸â€â™€ï¸ En y regardant de plus prÃ¨s, si on revient dans la fonction "vm_init" on se rend compte que ce qui pointÃ© sur "A" c'Ã©tait le code de la VM d'une taille de 0x54 : 

![](attachment/fda775008b17254e36c09eb9964622ef.png)

![](attachment/bbd604bdc3654cfb593c92f893552971.png)

ğŸ•µï¸â€â™€ï¸ Donc, en premier dans le buffer on a le code puis 0x54 est placÃ© juste avant  rsp !

ğŸ•µï¸â€â™€ï¸ Dans gdb on va mettre un breakpoint pour rÃ©cupÃ©rer l'emplacement mÃ©moire du buffer de la vm  pour surveiller les valeurs dans la stack

ğŸ•µï¸â€â™€ï¸ On va vÃ©rifier cette hypothÃ¨se, en allant rÃ©cupÃ©rer l'adresse de la stack (virtuelle) avec gdb. 

![](attachment/7796e727929032f765ae77b085e19474.png)

ğŸ•µï¸â€â™€ï¸ dans la premiÃ¨re partie du buffer, on a un pointer vers l'emplacement mÃ©moire du code de la vm :

![](attachment/8ed568d727b3d3f46d9be0cfe25e65fc.png)

![](attachment/6b6b02c4841d6e6bb1f374ae2e1e996f.png)

ğŸ•µï¸â€â™€ï¸ Ensuite, on a bien le 54 de la fonction init qui est placÃ© dans le buffer : 

![](attachment/48ca58d8b2a347a3b66180da938cb108.png)


Pour rÃ©capituler on Ã  :
`- break *0x40135b puis p *(unsigned char *)($rsp+0x30)` Pour rÃ©cupÃ©rer la valeur de eip Ã  chaque tour,
- `x/w 0x4052a0+12` -> premiÃ©re valeur de la stack
- `x/w 0x4052a0+16` -> deuxiÃ©me valeur de la stack

ğŸ•µï¸â€â™€ï¸ Instrumentons gdb afin d'afficher nos valeurs au fur et Ã  mesure du programme : 

```python
from pwn import *


local_file = './4_chal'


gdb_script = """
set logging on
set logging file gdb_output.txt
break *0x40135b
commands
silent
printf "Valeur de eip : "
p *(unsigned char *)($rsp+0x30)
printf "Premier Ã©lÃ©ment de la stack : "
x/w 0x4052a0+12
printf "DeuxiÃ©me Ã©lÃ©ment de la stack : "
x/w 0x4052a0+16
printf "\\n"
continue
end
run
"""


p = process(local_file)


gdb = gdb.attach(p, gdbscript=gdb_script, api=True)
p.interactive()
p.close()
call_value = []
stack_begin_1 = []
stack_begin_2 = []

call_pattern = re.compile(r"Valeur de eip : \$(\d+) = 0x([0-9a-fA-F]+)")
stack_begin_function = re.compile(r"Premier Ã©lÃ©ment de la stack : (0x[0-9a-fA-F]{1,8}):\s*(0x[0-9a-fA-F]+)")
stack_begin_function2 = re.compile(r"DeuxiÃ©me Ã©lÃ©ment de la stack : (0x[0-9a-fA-F]{1,8}):\s*(0x[0-9a-fA-F]+)")
with open('./gdb.txt') as file:
 for line in file:
    match_call = re.findall(call_pattern,line)
    match_begin_stack = re.findall(stack_begin_function,line)
    match_begin_stack2 = re.findall(stack_begin_function2,line)
    call_value.extend(match_call)
    stack_begin_1.extend(match_begin_stack)
    stack_begin_2.extend(match_begin_stack2)
print("call value:", call_value)
print("First stack value:", stack_begin_1)
print("Second stack value: ", stack_begin_2)
```

ğŸ•µï¸â€â™€ï¸ Si je lance mon script, je tombe sur 

![](attachment/eb35ed00bd6b79224027c3c58d2f6d44.png)
Donc 0xf est censÃ© Ãªtre la fonction de rÃ©cupÃ©ration de l'user input ! Allons voir Ã§a dans IDA : 

![](attachment/ff420853ed3949cded2c9b0016176692.png)

C'est parfait Ã§a !! ğŸ¤©
ğŸ•µï¸â€â™€ï¸ Maintenant que j'ai identifiÃ© quelques fonctions, je vais les rajouter dans mon output : 

```python
from pwn import *


local_file = './4_chal'


gdb_script = """
set logging on
set logging overwrite on
set logging file gdb_output.txt

# RÃ©cupÃ©ration de eip
break *0x40135b
commands
silent
printf "Valeur de eip : "
p *(unsigned char *)($rsp+0x30)
printf "\\n"
continue
end

# RÃ©cupÃ©ration de la stack
break *0x4017E9
commands
silent
printf "Premier Ã©lÃ©ment de la stack en dÃ©but de fonction: "
x/w 0x4052a0+12
printf "DeuxiÃ¨me Ã©lÃ©ment de la stack en dÃ©but de fonction: "
x/w 0x4052a0+16
printf "\\n"
continue
end


run

"""
try:
   
    p = process(local_file)

       
    gdb = gdb.attach(p, gdbscript=gdb_script, api=True)
    p.interactive()
    p.close()

        
    call_value = []
    stack_begin_1 = []
    stack_begin_2 = []
    stack_end_1 = []
    stack_end_2 = []
    
    call_pattern = re.compile(r"Valeur de eip : \$(\d+) = 0x([0-9a-fA-F]+)")
    stack_begin_function = re.compile(r"Premier Ã©lÃ©ment de la stack : (0x[0-9a-fA-F]{1,8}):\s*(0x[0-9a-fA-F]+)")
    stack_begin_function2 = re.compile(r"DeuxiÃ©me Ã©lÃ©ment de la stack : (0x[0-9a-fA-F]{1,8}):\s*(0x[0-9a-fA-F]+)")
    
    with open('./gdb.txt') as file:
        for line in file:
            match_call = re.findall(call_pattern,line)
            match_begin_stack = re.findall(stack_begin_function,line)
            match_begin_stack2 = re.findall(stack_begin_function2,line)


            call_value.extend(match_call)
            stack_begin_1.extend(match_begin_stack)
            stack_begin_2.extend(match_begin_stack2)
    
    functions_identification = {
        '1': "Add",
        '2': "Sub",
        '3': "Mul",
        '4': "Inferior or Egal",
        '5': "CMP",
        '6': "6",
        '7': "7",
        '8': "8",
        '9': "9",
        'a': "load?",
        'c': "store?",
        'e': "printf",
        'f': "Scanf",
        '11': "call?",
        '12': "12"
    }
   
    
    for call, stack, stack2 in zip(call_value,stack_begin_1,stack_begin_2) :
        print(f"func -> {functions_identification[call[1]]} \nSTACK1 : {stack[1]} STACK2 : {stack2[1]}\n")
    
      
except Exception as e:
    print(f"Erreur : {e}")


```

![](attachment/ebad2b401cc36f2d41fd0a3c8c84d8b6.png)

ğŸ•µï¸â€â™€ï¸ J'aimerais bien modifier mon script pour qu'il me donne la valeur de la stack Ã  la fin de chaque fonction !

```python
from pwn import *


local_file = './4_chal'

gdb_script = """
set logging on
set logging overwrite on
set logging file gdb_output.txt

# Premier breakpoint
break *0x40135b
commands
silent
printf "Valeur de eip : "
p *(unsigned char *)($rsp+0x30)
printf "\\n"
continue
end

# DeuxiÃ¨me breakpoint
break *0x4017E9
commands
silent
printf "Premier Ã©lÃ©ment de la stack en dÃ©but de fonction: "
x/w 0x4052a0+12
printf "DeuxiÃ¨me Ã©lÃ©ment de la stack en dÃ©but de fonction: "
x/w 0x4052a0+16
printf "\\n"
continue
end

# Lancer le programme
run

"""
try:
  
    p = process(local_file)

    
    gdb = gdb.attach(p, gdbscript=gdb_script, api=True)
    p.interactive()
    p.close()

        
    call_value = []
    stack_begin_1 = []
    stack_begin_2 = []
    stack_end_1 = []
    stack_end_2 = []
 
    call_pattern = re.compile(r"Valeur de eip : \$(\d+) = 0x([0-9a-fA-F]+)")
    stack_begin_function = re.compile(r"Premier Ã©lÃ©ment de la stack : (0x[0-9a-fA-F]{1,8}):\s*(0x[0-9a-fA-F]+)")
    stack_begin_function2 = re.compile(r"DeuxiÃ©me Ã©lÃ©ment de la stack : (0x[0-9a-fA-F]{1,8}):\s*(0x[0-9a-fA-F]+)")
    
    with open('./gdb.txt') as file:
        for line in file:
            match_call = re.findall(call_pattern,line)
            match_begin_stack = re.findall(stack_begin_function,line)
            match_begin_stack2 = re.findall(stack_begin_function2,line)


            call_value.extend(match_call)
            stack_begin_1.extend(match_begin_stack)
            stack_begin_2.extend(match_begin_stack2)
    
    functions_identification = {
        '1': "Add",
        '2': "Sub",
        '3': "Mul",
        '4': "Inferior or Egal",
        '5': "CMP",
        '6': "6",
        '7': "7",
        '8': "8",
        '9': "9",
        'a': "load?",
        'c': "store?",
        'e': "printf",
        'f': "Scanf",
        '11': "call?",
        '12': "12"
    }
   
    
    for call, stack, stack2 in zip(call_value,stack_begin_1,stack_begin_2) :
        print(f"func -> {functions_identification[call[1]]} \nSTACK1 : {int(stack[1],16)} STACK2 : {int(stack2[1],16)}\n")
    
      
except Exception as e:
    print(f"Erreur : {e}")

```

![](attachment/22e540909c01c8c9486e7b7f8b3e7dc6.png)

ğŸ•µï¸â€â™€ï¸ On commence Ã  deviner ce qu'il se trÃ¢me !!! ici on peut voir une comparaison entre 21 et 13371337

ğŸ•µï¸â€â™€ï¸ Si on pouvait afficher le retour de la fonction Ã§a serait encore mieux ! 

![](attachment/270c0c1bd2c6c6a4635c3b9b08fcee83.png)

ğŸ•µï¸â€â™€ï¸ Pour voir si la valeur de retour est bien stockÃ©e au sommet de la stack je vais break (dans gdb) dans ma fonction "scanf", car je contrÃ´le l'input, et je vais break en fin de boucle pour observer la valeur de la stack :

![](attachment/7bce70d0d24e99dea8fb7dacae2ef060.png)
Je mets 35 en input :

![](attachment/44f923292347b0616743c7aadd0f2fa0.png)
Et je retrouve bien mon 35 (0x25) en sommet de stack !

![](attachment/227013a95b619dbb05ef574e7da0b303.png)

ğŸ•µï¸â€â™€ï¸ Dans notre version du programme on observe dÃ©jÃ  que la valeur de retour se situe en premiÃ¨re arguments de la prochaine fonction :

![](attachment/56255672bdcca9fd644eaf9956cb999f.png)

ğŸš§ Je me suis rendu compte qu'avec gdb et pwntools mon script ne prenait pas en compte mon input utilisateur et mettait 1 par dÃ©faut... Pour palier Ã  ce problÃ¨me, j 'ai fait un script gdb Ã  part et j'ai parsÃ© les logs avec un script python. 

1ï¸âƒ£ gdb script : 

```bash
file ./4_chal
set logging on
set logging overwrite on
set logging file gdb_output.txt


break *0x40135b
commands
silent
printf "Valeur de eip : "
p *(unsigned char *)($rsp+0x30)
printf "\\n"
continue
end


break *0x4017E9
commands
silent
printf "Premier Ã©lÃ©ment de la stack en dÃ©but de fonction: "
x/w 0x4052a0+12
printf "DeuxiÃ¨me Ã©lÃ©ment de la stack en dÃ©but de fonction: "
x/w 0x4052a0+16
printf "\\n"
continue
end

run
```

Pour le lancer il faut ajouter cette ligne dans ~/.gdbinit

```bash
source ~/.gef-2024.06.py
source /home/relinux/Documents/cours_reverse_utt_publique-master/exercices/day_3_malware/4_VM/dist/gdb_script.gdb
```

Puis lancer gdb :

```
gdb
```

Il va faire le travaille et sauvegarder l'output dans gdb.txt

2ï¸âƒ£ On va parser l'output avec python : 

```python
from pwn import *

call_value = []
stack_begin_1 = []
stack_begin_2 = []
stack_end_1 = []
stack_end_2 = []


call_pattern = re.compile(r"Valeur de eip : \$(\d+) = 0x([0-9a-fA-F]+)")
stack_begin_function = re.compile(r"Premier Ã©lÃ©ment de la stack en dÃ©but de fonction:\s*(0x[0-9a-fA-F]+):\s*(0x[0-9a-fA-F]+)")
stack_begin_function2 = re.compile(r"DeuxiÃ¨me Ã©lÃ©ment de la stack en dÃ©but de fonction:\s*(0x[0-9a-fA-F]+):\s*(0x[0-9a-fA-F]+)")

with open('./gdb.txt','r') as file:
    for line in file:
       
        match_call = re.findall(call_pattern,line)
        match_begin_stack = re.findall(stack_begin_function,line)
        match_begin_stack2 = re.findall(stack_begin_function2,line)
        

        call_value.extend(match_call)
        stack_begin_1.extend(match_begin_stack)
        stack_begin_2.extend(match_begin_stack2)
        
functions_identification = {
    '1': "ADD",
    '2': "SUB",
    '3': "MUL",
    '4': ">=",
    '5': "CMP",
    '6': "6",
    '7': "7",
    '8': "8",
    '9': "9",
    'a': "load?",
    'c': "store?",
    'e': "PRINTF",
    'f': "SCANF",
    '11': "CALL?",
    '12': "12"
}


""" for call, stack, stack2 in zip(call_value,stack_begin_1,stack_begin_2) :
    print(f"func --[ {functions_identification[call[1]]} ]-- \n\nSTACK1 : {int(stack[1],16)} STACK2 : {int(stack2[1],16)} ") """
GREEN = "\033[32m"
RED = "\033[31m"
RESET = "\033[0m"
YELLOW = "\033[33m"
BOLD = "\033[1m"

for i in range(len(call_value)):
    print(f"Fonction --[ {RED}{functions_identification[call_value[i][1]]}{RESET} ]--")
    print(f"Arg 1 : {GREEN}{int(stack_begin_1[i-1][1], 16)}{RESET}  Arg2 (optionnel) : {GREEN}{int(stack_begin_2[i][1], 16)}{RESET}")
    print(f"Return value: {BOLD}{YELLOW}{int(stack_begin_1[i+1][1], 16)}{RESET}")
    print()  
```

ğŸ•µï¸â€â™€ï¸ Pour la dÃ©monstration, j'ai mis l'input 1000, ca nous donne (aprÃ©s execution de mon script) :

![](attachment/f0e42162fb46014894cb143eb4605da9.png)

On identifie bien notre scanf qui renvoit notre input Ã©gal Ã  '1000'

ğŸ’£ on peut rapidement se rendre compte qu'il y a peu d'instruction dâ€™IntÃ©rÃªts pour nous :

![](attachment/a03b343284f982d47eb555b7556e56ec.png)

ğŸ’£ Donc pour valider la comparaison, il faut que notre input soit = (13371337/7)-2 = 1910189

![](attachment/ede1be46886c5028632fc5ecc71e0dd9.png)

ğŸ’£ Testons cette input dans notre programme : 

![](attachment/133e9e2eea3cb4532e032be63f484a4c.png)

ğŸ’£ On a enfin gagnÃ© !!!! ğŸ‡
